<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>UnityURPshader光照部分学习分析（上）-基本结构 | EmiteInna</title><meta name="author" content="EmiteInna"><meta name="copyright" content="EmiteInna"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="最近看了RTR，想深入探索一下URP的源文件的光照部分，从而总结一套RP里比较通用的光照，拒绝代码黑盒化，版本为URP12.1。">
<meta property="og:type" content="article">
<meta property="og:title" content="UnityURPshader光照部分学习分析（上）-基本结构">
<meta property="og:url" content="http://emiteinna.github.io/game/demo6/index.html">
<meta property="og:site_name" content="EmiteInna">
<meta property="og:description" content="最近看了RTR，想深入探索一下URP的源文件的光照部分，从而总结一套RP里比较通用的光照，拒绝代码黑盒化，版本为URP12.1。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://emiteinnakuru.oss-cn-shanghai.aliyuncs.com/image/images/qt03.jpg">
<meta property="article:published_time" content="2023-04-08T04:58:59.000Z">
<meta property="article:modified_time" content="2023-04-09T06:47:51.884Z">
<meta property="article:author" content="EmiteInna">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://emiteinnakuru.oss-cn-shanghai.aliyuncs.com/image/images/qt03.jpg"><link rel="shortcut icon" href="https://emiteinnakuru.oss-cn-shanghai.aliyuncs.com/image/images/knifesmall.png"><link rel="canonical" href="http://emiteinna.github.io/game/demo6/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'UnityURPshader光照部分学习分析（上）-基本结构',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2023-04-09 14:47:51'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/cursor.min.css"><meta name="generator" content="Hexo 6.3.0"><link rel="stylesheet" href="\css\APlayer.min.css" class="aplayer-style-marker">
<script src="\js\APlayer.min.js" class="aplayer-script-marker"></script>
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (false) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://emiteinnakuru.oss-cn-shanghai.aliyuncs.com/image/images/knifesmall.png" onerror="onerror=null;src='https://emiteinnakuru.oss-cn-shanghai.aliyuncs.com/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">89</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">3</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://emiteinnakuru.oss-cn-shanghai.aliyuncs.com/image/images/qt03.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="EmiteInna"><img class="site-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://emiteinnakuru.oss-cn-shanghai.aliyuncs.com/image/images/knife.png"/><span class="site-name">EmiteInna</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">UnityURPshader光照部分学习分析（上）-基本结构</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-04-08T04:58:59.000Z" title="Created 2023-04-08 12:58:59">2023-04-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2023-04-09T06:47:51.884Z" title="Updated 2023-04-09 14:47:51">2023-04-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/TA/">TA</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word count:</span><span class="word-count">5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading time:</span><span>21min</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="UnityURPshader光照部分学习分析（上）-基本结构"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote>
<p>神说要有光，于是便有了光。EmiteInna说要有光，他的shader粉了。</p>
<p>这次笔记没什么美术含量，算是一个代码解析，如果有错误的地方欢迎勘误。</p>
</blockquote>

        <div id="aplayer-RiKrkbTS" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;"></div>
			  <script>
				  var options = {"narrow":false,"autoplay":false,"showlrc":0,"mode":"random","mutex":true,"theme":"#e6d0b2","preload":"metadata","listmaxheight":"513px","music":[{"title":"玻璃の空","author":"小清水亚美","url":"https://emiteinnakuru.oss-cn-shanghai.aliyuncs.com/music/glasssora.mp3","pic":""}]};
				  options.element = document.getElementById("aplayer-RiKrkbTS");
				  var ap = new APlayer(options);
			    window.aplayers || (window.aplayers = []);
				  window.aplayers.push(ap);
			  </script>

<h1 id="UnityURPshader光照部分学习分析（上）-基本结构"><a href="#UnityURPshader光照部分学习分析（上）-基本结构" class="headerlink" title="UnityURPshader光照部分学习分析（上）-基本结构"></a>UnityURPshader光照部分学习分析（上）-基本结构</h1><h2 id="BRDF方程"><a href="#BRDF方程" class="headerlink" title="BRDF方程"></a>BRDF方程</h2><p>首先，在这里放置一个cook-torrance的BRDF方程，对照着这个来分析代码。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://emiteinnakuru.oss-cn-shanghai.aliyuncs.com/image/images/games/demo7/png01.png" alt="公式"></p>
<p>公式图来自其他大佬的整理。</p>
<h2 id="Lighting-hlsl"><a href="#Lighting-hlsl" class="headerlink" title="Lighting.hlsl"></a>Lighting.hlsl</h2><p>首先看Lighting.hlsl里面，前两个是我们再熟悉不过的兰伯特漫反射和BlinnPhong高光算法。</p>
<figure class="highlight plaintext"><figcaption><span>代码</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">half3 LightingLambert(half3 lightColor, half3 lightDir, half3 normal)</span><br><span class="line">&#123;</span><br><span class="line">    half NdotL = saturate(dot(normal, lightDir));</span><br><span class="line">    return lightColor * NdotL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">half3 LightingSpecular(half3 lightColor, half3 lightDir, half3 normal, half3 viewDir, half4 specular, half smoothness)</span><br><span class="line">&#123;</span><br><span class="line">    float3 halfVec = SafeNormalize(float3(lightDir) + float3(viewDir));</span><br><span class="line">    half NdotH = half(saturate(dot(normal, halfVec)));</span><br><span class="line">    half modifier = pow(NdotH, smoothness);</span><br><span class="line">    half3 specularReflection = specular.rgb * modifier;</span><br><span class="line">    return lightColor * specularReflection;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>往后出现了LightingPhysicallyBased函数，这个函数大概就是Unity自己的PBR函数之一，他的参数包含两个BRDFData结构体——brdfData,brdfDataClearCoat，和一些输入，包括lightColor,lightDirectionWS,lightAttenuation,normalWS,viewDirectionWS,clearCoatMask,specularHighlightsOff，大体都是比较熟悉的变量。</p>
<p>为了搞明白所有的参数，先进入BRDF.hlsl里去看看。</p>
<h3 id="BRDF-hlsl"><a href="#BRDF-hlsl" class="headerlink" title="BRDF.hlsl"></a>BRDF.hlsl</h3><figure class="highlight plaintext"><figcaption><span>代码</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">struct BRDFData</span><br><span class="line">&#123;</span><br><span class="line">    half3 albedo;</span><br><span class="line">    half3 diffuse;</span><br><span class="line">    half3 specular;</span><br><span class="line">    half reflectivity;</span><br><span class="line">    half perceptualRoughness;</span><br><span class="line">    half roughness;</span><br><span class="line">    half roughness2;</span><br><span class="line">    half grazingTerm;</span><br><span class="line"></span><br><span class="line">    // We save some light invariant BRDF terms so we don&#x27;t have to recompute</span><br><span class="line">    // them in the light loop. Take a look at DirectBRDF function for detailed explaination.</span><br><span class="line">    half normalizationTerm;     // roughness * 4.0 + 2.0</span><br><span class="line">    half roughness2MinusOne;    // roughness^2 - 1.0</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>声明了一些基础变量和额外变量，额外变量在代码中URP也写了注释，但是有些还是难以理解（因为不出现在cook-torrance的方程里，比如grazingTerm掠射角项、perceptualRoughness感知粗糙度(字面翻译..)）即使不理解也没关系，等着看后面的代码。</p>
<p>同时，BRDF.hlsl文件定义了非电解质的反射率0（也就是F0）为(0.04,0.04,0.04,1-0.04)。以及一些能够为BRDF数据做好初始化的其它转换函数，在这里它又用到了BSDF.hlsl、CommonMaterial.hlsl、Deprecated.hlsl、SurfaceData.hlsl四个hlsl文件，从后往前去看。</p>
<h3 id="SurfaceData-hlsl"><a href="#SurfaceData-hlsl" class="headerlink" title="SurfaceData.hlsl"></a>SurfaceData.hlsl</h3><p>这个文件就是一个非常简单的声明结构体的文件，它包含了一些我们经常会用到的数据。</p>
<figure class="highlight plaintext"><figcaption><span>代码</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">struct SurfaceData</span><br><span class="line">&#123;</span><br><span class="line">    half3 albedo;</span><br><span class="line">    half3 specular;</span><br><span class="line">    half  metallic;</span><br><span class="line">    half  smoothness;</span><br><span class="line">    half3 normalTS;</span><br><span class="line">    half3 emission;</span><br><span class="line">    half  occlusion;</span><br><span class="line">    half  alpha;</span><br><span class="line">    half  clearCoatMask;</span><br><span class="line">    half  clearCoatSmoothness;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>基础反射率albedo、高光值specular、金属度metallic、平滑度smoothness、切线空间法线normalTS、emission自发光、occlusion环境吸收、alpha透明度，两个clearCoat之后再看。</p>
<h3 id="回到BRDF-hlsl-不那么熟悉的BRDF方程"><a href="#回到BRDF-hlsl-不那么熟悉的BRDF方程" class="headerlink" title="回到BRDF.hlsl-不那么熟悉的BRDF方程"></a>回到BRDF.hlsl-不那么熟悉的BRDF方程</h3><p>熟悉catlikecoding的大佬们可能会发现surfaceData到BRDFData的这个过程和catlikecoding教程里的SRP系列是同一个写法（毕竟教程里也说了是模仿URP写的）。</p>
<p>但实际上我们发现BRDF.hlsl好像并没有强制用到SurfaceData，而只是把它用作初始化BRDF的一个选项。</p>
<p>InitializeBRDFDataDirect()函数直接把输出的BRDFData按顺序填进去，而实际上用于初始化的代码是IntializeBRDFData函数，它用_SPECULAR_STEP宏把BRDFdata的初始化分为了金属流和高光流两种，在初始化上有一些区别（主要在于处理reflectivity、brdfDiffuse、brdfSpecular）</p>
<p>暂且跳过关于clearcoat的部分，往下看到EnvironmentBRDF函数。</p>
<figure class="highlight plaintext"><figcaption><span>代码</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">half3 EnvironmentBRDFSpecular(BRDFData brdfData, half fresnelTerm)</span><br><span class="line">&#123;</span><br><span class="line">    float surfaceReduction = 1.0 / (brdfData.roughness2 + 1.0);</span><br><span class="line">    return half3(surfaceReduction * lerp(brdfData.specular, brdfData.grazingTerm, fresnelTerm));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">half3 EnvironmentBRDF(BRDFData brdfData, half3 indirectDiffuse, half3 indirectSpecular, half fresnelTerm)</span><br><span class="line">&#123;</span><br><span class="line">    half3 c = indirectDiffuse * brdfData.diffuse;</span><br><span class="line">    c += indirectSpecular * EnvironmentBRDFSpecular(brdfData, fresnelTerm);</span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后是DirectBRDFSpecular</p>
<figure class="highlight plaintext"><figcaption><span>代码</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// Computes the scalar specular term for Minimalist CookTorrance BRDF</span><br><span class="line">// NOTE: needs to be multiplied with reflectance f0, i.e. specular color to complete</span><br><span class="line">half DirectBRDFSpecular(BRDFData brdfData, half3 normalWS, half3 lightDirectionWS, half3 viewDirectionWS)</span><br><span class="line">&#123;</span><br><span class="line">    float3 lightDirectionWSFloat3 = float3(lightDirectionWS);</span><br><span class="line">    float3 halfDir = SafeNormalize(lightDirectionWSFloat3 + float3(viewDirectionWS));</span><br><span class="line"></span><br><span class="line">    float NoH = saturate(dot(float3(normalWS), halfDir));</span><br><span class="line">    half LoH = half(saturate(dot(lightDirectionWSFloat3, halfDir)));</span><br><span class="line">    </span><br><span class="line">    // GGX Distribution multiplied by combined approximation of Visibility and Fresnel</span><br><span class="line">    // BRDFspec = (D * V * F) / 4.0</span><br><span class="line">    // D = roughness^2 / ( NoH^2 * (roughness^2 - 1) + 1 )^2</span><br><span class="line">    // V * F = 1.0 / ( LoH^2 * (roughness + 0.5) )</span><br><span class="line">    // See &quot;Optimizing PBR for Mobile&quot; from Siggraph 2015 moving mobile graphics course</span><br><span class="line">    // https://community.arm.com/events/1155</span><br><span class="line">    </span><br><span class="line">    // Final BRDFspec = roughness^2 / ( NoH^2 * (roughness^2 - 1) + 1 )^2 * (LoH^2 * (roughness + 0.5) * 4.0)</span><br><span class="line">    // We further optimize a few light invariant terms</span><br><span class="line">    // brdfData.normalizationTerm = (roughness + 0.5) * 4.0 rewritten as roughness * 4.0 + 2.0 to a fit a MAD.</span><br><span class="line">    float d = NoH * NoH * brdfData.roughness2MinusOne + 1.00001f;</span><br><span class="line">    </span><br><span class="line">    half LoH2 = LoH * LoH;</span><br><span class="line">    half specularTerm = brdfData.roughness2 / ((d * d) * max(0.1h, LoH2) * brdfData.normalizationTerm);</span><br><span class="line">    </span><br><span class="line">    // On platforms where half actually means something, the denominator has a risk of overflow</span><br><span class="line">    // clamp below was added specifically to &quot;fix&quot; that, but dx compiler (we convert bytecode to metal/gles)</span><br><span class="line">    // sees that specularTerm have only non-negative terms, so it skips max(0,..) in clamp (leaving only min(100,...))</span><br><span class="line">#if defined (SHADER_API_MOBILE) || defined (SHADER_API_SWITCH)</span><br><span class="line">    specularTerm = specularTerm - HALF_MIN;</span><br><span class="line">    specularTerm = clamp(specularTerm, 0.0, 100.0); // Prevent FP16 overflow on mobiles</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">return specularTerm;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>直接光的brdf就好了很多，unity在注释里为我们细说了每一行公式的意义。</p>
<p>根据注释，Unity的高光反射项和文章顶部的公式并不是相同的。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://emiteinnakuru.oss-cn-shanghai.aliyuncs.com/image/images/games/demo7/png02.png" alt="图片"></p>
<p>这是我们数值的cook-torrance方程的高光反射项，而unity中的高光反射项是这样的</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://emiteinnakuru.oss-cn-shanghai.aliyuncs.com/image/images/games/demo7/png03.png" alt="图片"></p>
<p>这个公式的来源是Siggraph 2015中的”Optimzing PBR For Moblie”</p>
<p>在unity中这个函数的表达做了一些运算上的优化，我们可以发现它并没有4(roughness+0.5)这个项，而是使用了brdfData.normalizationTerm这个项，而在我们的InitializeBRDFDataDirect()函数中可以窥见这个变量，它的值确实就是roughness*4+2。</p>
<p>在DirectBDRF（没错，确实是BDRF，算是彩蛋吗？）函数里unity选择用brdfData的diffuse项和高光项乘过一个金属和albedo的插值相加来获得brdf值输出，而这个diffuse项呢？我们也在IntializeBRDFDataDirect()函数里去看看，可以发现它在金属流下的公式是half3 brdfDiffuse &#x3D; albedo * oneMinusReflectivity;</p>
<figure class="highlight plaintext"><figcaption><span>代码</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// Initialize BRDFData for material, managing both specular and metallic setup using shader keyword _SPECULAR_SETUP.</span><br><span class="line">inline void InitializeBRDFData(half3 albedo, half metallic, half3 specular, half smoothness, inout half alpha, out BRDFData outBRDFData)</span><br><span class="line">&#123;</span><br><span class="line">#ifdef _SPECULAR_SETUP</span><br><span class="line">    half reflectivity = ReflectivitySpecular(specular);</span><br><span class="line">    half oneMinusReflectivity = half(1.0) - reflectivity;</span><br><span class="line">    half3 brdfDiffuse = albedo * (half3(1.0, 1.0, 1.0) - specular);</span><br><span class="line">    half3 brdfSpecular = specular;</span><br><span class="line">#else</span><br><span class="line">    half oneMinusReflectivity = OneMinusReflectivityMetallic(metallic);</span><br><span class="line">    half reflectivity = half(1.0) - oneMinusReflectivity;</span><br><span class="line">    half3 brdfDiffuse = albedo * oneMinusReflectivity;</span><br><span class="line">    half3 brdfSpecular = lerp(kDieletricSpec.rgb, albedo, metallic);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    InitializeBRDFDataDirect(albedo, brdfDiffuse, brdfSpecular, reflectivity, oneMinusReflectivity, smoothness, alpha, outBRDFData);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们知道kd项是公式是(1-F0)(1-Metallic)，而这个oneMinusReflectivity是根据另一个函数算出。</p>
<figure class="highlight plaintext"><figcaption><span>代码</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">half OneMinusReflectivityMetallic(half metallic)</span><br><span class="line">&#123;</span><br><span class="line">    // We&#x27;ll need oneMinusReflectivity, so</span><br><span class="line">    //   1-reflectivity = 1-lerp(dielectricSpec, 1, metallic) = lerp(1-dielectricSpec, 0, metallic)</span><br><span class="line">    // store (1-dielectricSpec) in kDielectricSpec.a, then</span><br><span class="line">    //   1-reflectivity = lerp(alpha, 0, metallic) = alpha + metallic*(0 - alpha) =</span><br><span class="line">    //                  = alpha - metallic * alpha</span><br><span class="line">    half oneMinusDielectricSpec = kDielectricSpec.a;</span><br><span class="line">    return oneMinusDielectricSpec - metallic * oneMinusDielectricSpec;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>kDielectriSpec.a就是(1-F0)这个项，很容易得知oneMinusReflectivity这个项就是kd项，那么问题来了，式子里的漫反射项应该是还要除以π的，但是unity里却没有除以π，这似乎是一个经常被群友提及的话题，个人认为这是unity觉得没必要除以这个π也能获得不错的效果，unity说不用那就不用吧……</p>
<p>看完这些好像对于BRDF.hlsl有个大概的理解了，但如果要追求更深的理解，还需要去继续往下看剩下的几个core里的头文件干了什么。</p>
<h3 id="BSDF-hlsl"><a href="#BSDF-hlsl" class="headerlink" title="BSDF.hlsl"></a>BSDF.hlsl</h3><p>这位更是重量级，BSDF.hlsl可以说是一个关于反射方程的参考库，unity在每个算法中都为我们注释了论文来源，可以用来参考和学习。</p>
<p>文件里包含各种各样的Fresnel、GGX、Irediscence、Fabric材质和flowmap位移切线的kajiya头发渲染。</p>
<h3 id="CommonMaterial-hlsl"><a href="#CommonMaterial-hlsl" class="headerlink" title="CommonMaterial.hlsl"></a>CommonMaterial.hlsl</h3><p>这个文件里包含了一些基础材质算法和函数的代码，同样标注了论文来源，在BRDF.hlsl只用了一个转换smoothness为roughness的算法，它的代码是这样的。</p>
<figure class="highlight plaintext"><figcaption><span>代码</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">real RoughnessToPerceptualSmoothness(real roughness)</span><br><span class="line">&#123;</span><br><span class="line">    return 1.0 - sqrt(roughness);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">real PerceptualSmoothnessToRoughness(real perceptualSmoothness)</span><br><span class="line">&#123;</span><br><span class="line">    return (1.0 - perceptualSmoothness) * (1.0 - perceptualSmoothness);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">real PerceptualSmoothnessToPerceptualRoughness(real perceptualSmoothness)</span><br><span class="line">&#123;</span><br><span class="line">    return (1.0 - perceptualSmoothness);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="回到Lighting-hlsl"><a href="#回到Lighting-hlsl" class="headerlink" title="回到Lighting.hlsl"></a>回到Lighting.hlsl</h3><p>解决了BRDFData的问题（并没），接下来继续回头看LightingPhysicallyBased干了什么。从刚刚对BRDF的分析可以得知，BRDFData这个结构体里存储的都是微表面本身的属性（不包含法线方向），而LightingPhysicallyBased函数里传入的其它数据则是法线方向、光照方向、视角方向、光照衰减、光照颜色等和表面本身无关的属性，分离了数据使整个系统更加成熟。</p>
<figure class="highlight plaintext"><figcaption><span>代码</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">half NdotL = saturate(dot(normalWS, lightDirectionWS));</span><br><span class="line">    half3 radiance = lightColor * (lightAttenuation * NdotL);</span><br><span class="line"></span><br><span class="line">    half3 brdf = brdfData.diffuse;</span><br><span class="line">#ifndef _SPECULARHIGHLIGHTS_OFF</span><br><span class="line">    [branch] if (!specularHighlightsOff)</span><br><span class="line">    &#123;</span><br><span class="line">        brdf += brdfData.specular * DirectBRDFSpecular(brdfData, normalWS, lightDirectionWS, viewDirectionWS);</span><br><span class="line"></span><br><span class="line">#if defined(_CLEARCOAT) || defined(_CLEARCOATMAP)</span><br><span class="line">        // Clear coat evaluates the specular a second timw and has some common terms with the base specular.</span><br><span class="line">        // We rely on the compiler to merge these and compute them only once.</span><br><span class="line">        half brdfCoat = kDielectricSpec.r * DirectBRDFSpecular(brdfDataClearCoat, normalWS, lightDirectionWS, viewDirectionWS);</span><br><span class="line"></span><br><span class="line">            // Mix clear coat and base layer using khronos glTF recommended formula</span><br><span class="line">            // https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_materials_clearcoat/README.md</span><br><span class="line">            // Use NoV for direct too instead of LoH as an optimization (NoV is light invariant).</span><br><span class="line">            half NoV = saturate(dot(normalWS, viewDirectionWS));</span><br><span class="line">            // Use slightly simpler fresnelTerm (Pow4 vs Pow5) as a small optimization.</span><br><span class="line">            // It is matching fresnel used in the GI/Env, so should produce a consistent clear coat blend (env vs. direct)</span><br><span class="line">            half coatFresnel = kDielectricSpec.x + kDielectricSpec.a * Pow4(1.0 - NoV);</span><br><span class="line">    </span><br><span class="line">        brdf = brdf * (1.0 - clearCoatMask * coatFresnel) + brdfCoat * clearCoatMask;</span><br><span class="line">#endif // _CLEARCOAT</span><br><span class="line">    &#125;</span><br><span class="line">#endif // _SPECULARHIGHLIGHTS_OFF</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里出现了一个新的变量radiance，它的组成是光照乘NoL再乘一个衰减，除去这个衰减以外我们可以发现它对应的就是cook-torrance方程里的光照乘cosθ这一项，所以它乘上brdf确实就是光照的输出，而这里的高光运算运用的就是BRDF.hlsl中的DirectBRDFSpecular()函数。</p>
<p>发现就在不远处还有一个F项，define在了_CLEARCOAT里，并且用clearcoatmask值来控制，或者说对brdf用clearCoatMask做了一个brdfCoat到brdf*coatFresnel的插值，而brdfCoat如代码所示，是使用另一个BRDFData来进行DirectBRDFSpecular()函数运算得到的高光值再乘上0.04，我认为这是urp提供的一个金属和非金属混合制品的方便的计算方式（即带有coat宏的物体是作为金属来计算的）。</p>
<h3 id="正体-UniversalFragmentPBR"><a href="#正体-UniversalFragmentPBR" class="headerlink" title="正体-UniversalFragmentPBR"></a>正体-UniversalFragmentPBR</h3><p>文件中间是一堆对于光照的处理，之后进入了一个醒目的Fragment Functions板块，其中第一个函数UniversalFragmentPBR就比较值得一看。</p>
<figure class="highlight plaintext"><figcaption><span>代码</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">half4 UniversalFragmentPBR(InputData inputData, SurfaceData surfaceData)</span><br><span class="line">&#123;</span><br><span class="line">    #if defined(_SPECULARHIGHLIGHTS_OFF)</span><br><span class="line">    bool specularHighlightsOff = true;</span><br><span class="line">    #else</span><br><span class="line">    bool specularHighlightsOff = false;</span><br><span class="line">    #endif</span><br><span class="line">    BRDFData brdfData;</span><br><span class="line"></span><br><span class="line">    // NOTE: can modify &quot;surfaceData&quot;...</span><br><span class="line">    InitializeBRDFData(surfaceData, brdfData);</span><br><span class="line">    </span><br><span class="line">    #if defined(DEBUG_DISPLAY)</span><br><span class="line">    half4 debugColor;</span><br><span class="line">    </span><br><span class="line">    if (CanDebugOverrideOutputColor(inputData, surfaceData, brdfData, debugColor))</span><br><span class="line">    &#123;</span><br><span class="line">        return debugColor;</span><br><span class="line">    &#125;</span><br><span class="line">    #endif</span><br><span class="line">    </span><br><span class="line">    // Clear-coat calculation...</span><br><span class="line">    BRDFData brdfDataClearCoat = CreateClearCoatBRDFData(surfaceData, brdfData);</span><br><span class="line">    half4 shadowMask = CalculateShadowMask(inputData);</span><br><span class="line">    AmbientOcclusionFactor aoFactor = CreateAmbientOcclusionFactor(inputData, surfaceData);</span><br><span class="line">    uint meshRenderingLayers = GetMeshRenderingLightLayer();</span><br><span class="line">    Light mainLight = GetMainLight(inputData, shadowMask, aoFactor);</span><br><span class="line">    </span><br><span class="line">    // NOTE: We don&#x27;t apply AO to the GI here because it&#x27;s done in the lighting calculation below...</span><br><span class="line">    MixRealtimeAndBakedGI(mainLight, inputData.normalWS, inputData.bakedGI);</span><br><span class="line">    </span><br><span class="line">    LightingData lightingData = CreateLightingData(inputData, surfaceData);</span><br><span class="line">    </span><br><span class="line">    lightingData.giColor = GlobalIllumination(brdfData, brdfDataClearCoat, surfaceData.clearCoatMask,</span><br><span class="line">                                              inputData.bakedGI, aoFactor.indirectAmbientOcclusion, inputData.positionWS,</span><br><span class="line">                                              inputData.normalWS, inputData.viewDirectionWS);</span><br><span class="line">    </span><br><span class="line">    if (IsMatchingLightLayer(mainLight.layerMask, meshRenderingLayers))</span><br><span class="line">    &#123;</span><br><span class="line">        lightingData.mainLightColor = LightingPhysicallyBased(brdfData, brdfDataClearCoat,</span><br><span class="line">                                                              mainLight,</span><br><span class="line">                                                              inputData.normalWS, inputData.viewDirectionWS,</span><br><span class="line">                                                              surfaceData.clearCoatMask, specularHighlightsOff);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    #if defined(_ADDITIONAL_LIGHTS)</span><br><span class="line">    uint pixelLightCount = GetAdditionalLightsCount();</span><br><span class="line">    </span><br><span class="line">    #if USE_CLUSTERED_LIGHTING</span><br><span class="line">    for (uint lightIndex = 0; lightIndex &lt; min(_AdditionalLightsDirectionalCount, MAX_VISIBLE_LIGHTS); lightIndex++)</span><br><span class="line">    &#123;</span><br><span class="line">        Light light = GetAdditionalLight(lightIndex, inputData, shadowMask, aoFactor);</span><br><span class="line">    </span><br><span class="line">        if (IsMatchingLightLayer(light.layerMask, meshRenderingLayers))</span><br><span class="line">        &#123;</span><br><span class="line">            lightingData.additionalLightsColor += LightingPhysicallyBased(brdfData, brdfDataClearCoat, light,</span><br><span class="line">                                                                          inputData.normalWS, inputData.viewDirectionWS,</span><br><span class="line">                                                                          surfaceData.clearCoatMask, specularHighlightsOff);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    #endif</span><br><span class="line">    </span><br><span class="line">    LIGHT_LOOP_BEGIN(pixelLightCount)</span><br><span class="line">        Light light = GetAdditionalLight(lightIndex, inputData, shadowMask, aoFactor);</span><br><span class="line">    </span><br><span class="line">        if (IsMatchingLightLayer(light.layerMask, meshRenderingLayers))</span><br><span class="line">        &#123;</span><br><span class="line">            lightingData.additionalLightsColor += LightingPhysicallyBased(brdfData, brdfDataClearCoat, light,</span><br><span class="line">                                                                          inputData.normalWS, inputData.viewDirectionWS,</span><br><span class="line">                                                                          surfaceData.clearCoatMask, specularHighlightsOff);</span><br><span class="line">        &#125;</span><br><span class="line">    LIGHT_LOOP_END</span><br><span class="line">    #endif</span><br><span class="line">    </span><br><span class="line">    #if defined(_ADDITIONAL_LIGHTS_VERTEX)</span><br><span class="line">    lightingData.vertexLightingColor += inputData.vertexLighting * brdfData.diffuse;</span><br><span class="line">    #endif</span><br><span class="line">    </span><br><span class="line">    return CalculateFinalColor(lightingData, surfaceData.alpha);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个函数做了很多事情，或者说可能是全部事情，它根据输入的surfaceData创建了brdfData，然后又根据这个brdfData来创建了clearCoat，从此我们可以推出pbr使用的材质大抵上用这种方式计算了额外的F项完成了其它的效果，然后它计算了shadowMask、renderingLayer和GI，根据inputData和surfaceData创建了lightingData，然后遍历所有的光源进行光照计算（基于之前的LightingPhysicallyBased)，输出最后的颜色。</p>
<p>这个函数又带来了新的疑问：1.inputData是什么，很容易猜到，这个结构体大概包含了除平面本身信息以外的其它信息，那么为什么靠它可以算出lightingData呢？2.shadowmask怎么计算，又为什么要在这里进行计算？3.GI怎么计算？4.urp的内置shader如何去调用这个函数完成渲染流程？</p>
<p>我急了我急了，赶紧把剩下看完，哦，是关于phong、blinnphong和unlit的，跳过吧。</p>
<h3 id="Input-hlsl"><a href="#Input-hlsl" class="headerlink" title="Input.hlsl"></a>Input.hlsl</h3><p>先解决第一个问题，InputData是什么？这个结构体在DBuffer.hlsl所引用的Input.hlsl结构体中。</p>
<figure class="highlight plaintext"><figcaption><span>代码</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">struct InputData</span><br><span class="line">&#123;</span><br><span class="line">    float3  positionWS;</span><br><span class="line">    float4  positionCS;</span><br><span class="line">    half3   normalWS;</span><br><span class="line">    half3   viewDirectionWS;</span><br><span class="line">    float4  shadowCoord;</span><br><span class="line">    half    fogCoord;</span><br><span class="line">    half3   vertexLighting;</span><br><span class="line">    half3   bakedGI;</span><br><span class="line">    float2  normalizedScreenSpaceUV;</span><br><span class="line">    half4   shadowMask;</span><br><span class="line">    half3x3 tangentToWorld;</span><br><span class="line"></span><br><span class="line">    #if defined(DEBUG_DISPLAY)</span><br><span class="line">    half2   dynamicLightmapUV;</span><br><span class="line">    half2   staticLightmapUV;</span><br><span class="line">    float3  vertexSH;</span><br><span class="line">    </span><br><span class="line">    half3 brdfDiffuse;</span><br><span class="line">    half3 brdfSpecular;</span><br><span class="line">    float2 uv;</span><br><span class="line">    uint mipCount;</span><br><span class="line">    </span><br><span class="line">    // texelSize :</span><br><span class="line">    // x = 1 / width</span><br><span class="line">    // y = 1 / height</span><br><span class="line">    // z = width</span><br><span class="line">    // w = height</span><br><span class="line">    float4 texelSize;</span><br><span class="line">    </span><br><span class="line">    // mipInfo :</span><br><span class="line">    // x = quality settings minStreamingMipLevel</span><br><span class="line">    // y = original mip count for texture</span><br><span class="line">    // z = desired on screen mip level</span><br><span class="line">    // w = loaded mip level</span><br><span class="line">    float4 mipInfo;</span><br><span class="line">    #endif</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个结构体里包含了基础的positionWS、positionCS、normalWS、viewDirection，还包含了shadowCoord、fogCoord、bakedGI等等各种表面光照的函数，同时一些全局变量也是在这个文件里声明的，算是一个万用的匹配工具。</p>
<h3 id="告一段落"><a href="#告一段落" class="headerlink" title="告一段落"></a>告一段落</h3><p>shadowmap和gi的事情之后再去补充，先看到第二个问题：urp的shader怎么使用这个函数。</p>
<h2 id="Lit-shader"><a href="#Lit-shader" class="headerlink" title="Lit.shader"></a>Lit.shader</h2><p>研究过Lit.shader的人都知道，除开properties里的一大段东西和后面的一堆诸如shadowcaster和depthnormals之类的pass，这个shader的光照都是在”ForwardLit”这个pass里进行的。他的函数LitPassVertex和LitPassFragment在LitInput.hlsl和LitForwardPass.hlsl里，我们来看看这些文件。</p>
<h3 id="LitInput-hlsl和LitForwardPass-hlsl"><a href="#LitInput-hlsl和LitForwardPass-hlsl" class="headerlink" title="LitInput.hlsl和LitForwardPass.hlsl"></a>LitInput.hlsl和LitForwardPass.hlsl</h3><p>这个两个文件其实是一个文件，也就是我们常写的shader结构，在LitInput里声明了SRP Batcher和GPU Instancing的变量，并区分Metallic和Specular工作流，然后声明了一些采样用的函数，可以看作整个LitInput.hlsl文件是为LitForwardPass.hlsl作准备，并且做了一些比较普遍的工作。</p>
<figure class="highlight plaintext"><figcaption><span>代码</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// NOTE: Do not ifdef the properties here as SRP batcher can not handle different layouts.</span><br><span class="line">CBUFFER_START(UnityPerMaterial)</span><br><span class="line">float4 _BaseMap_ST;</span><br><span class="line">float4 _DetailAlbedoMap_ST;</span><br><span class="line">half4 _BaseColor;</span><br><span class="line">half4 _SpecColor;</span><br><span class="line">half4 _EmissionColor;</span><br><span class="line">half _Cutoff;</span><br><span class="line">half _Smoothness;</span><br><span class="line">half _Metallic;</span><br><span class="line">half _BumpScale;</span><br><span class="line">half _Parallax;</span><br><span class="line">half _OcclusionStrength;</span><br><span class="line">half _ClearCoatMask;</span><br><span class="line">half _ClearCoatSmoothness;</span><br><span class="line">half _DetailAlbedoMapScale;</span><br><span class="line">half _DetailNormalMapScale;</span><br><span class="line">half _Surface;</span><br><span class="line">CBUFFER_END</span><br><span class="line"></span><br><span class="line">// NOTE: Do not ifdef the properties for dots instancing, but ifdef the actual usage.</span><br><span class="line">// Otherwise you might break CPU-side as property constant-buffer offsets change per variant.</span><br><span class="line">// NOTE: Dots instancing is orthogonal to the constant buffer above.</span><br><span class="line">#ifdef UNITY_DOTS_INSTANCING_ENABLED</span><br><span class="line">UNITY_DOTS_INSTANCING_START(MaterialPropertyMetadata)</span><br><span class="line">    UNITY_DOTS_INSTANCED_PROP(float4, _BaseColor)</span><br><span class="line">    UNITY_DOTS_INSTANCED_PROP(float4, _SpecColor)</span><br><span class="line">    UNITY_DOTS_INSTANCED_PROP(float4, _EmissionColor)</span><br><span class="line">    UNITY_DOTS_INSTANCED_PROP(float , _Cutoff)</span><br><span class="line">    UNITY_DOTS_INSTANCED_PROP(float , _Smoothness)</span><br><span class="line">    UNITY_DOTS_INSTANCED_PROP(float , _Metallic)</span><br><span class="line">    UNITY_DOTS_INSTANCED_PROP(float , _BumpScale)</span><br><span class="line">    UNITY_DOTS_INSTANCED_PROP(float , _Parallax)</span><br><span class="line">    UNITY_DOTS_INSTANCED_PROP(float , _OcclusionStrength)</span><br><span class="line">    UNITY_DOTS_INSTANCED_PROP(float , _ClearCoatMask)</span><br><span class="line">    UNITY_DOTS_INSTANCED_PROP(float , _ClearCoatSmoothness)</span><br><span class="line">    UNITY_DOTS_INSTANCED_PROP(float , _DetailAlbedoMapScale)</span><br><span class="line">    UNITY_DOTS_INSTANCED_PROP(float , _DetailNormalMapScale)</span><br><span class="line">    UNITY_DOTS_INSTANCED_PROP(float , _Surface)</span><br><span class="line">UNITY_DOTS_INSTANCING_END(MaterialPropertyMetadata)</span><br><span class="line"></span><br><span class="line">#define _BaseColor              UNITY_ACCESS_DOTS_INSTANCED_PROP_FROM_MACRO(float4 , Metadata_BaseColor)</span><br><span class="line">#define _SpecColor              UNITY_ACCESS_DOTS_INSTANCED_PROP_FROM_MACRO(float4 , Metadata_SpecColor)</span><br><span class="line">#define _EmissionColor          UNITY_ACCESS_DOTS_INSTANCED_PROP_FROM_MACRO(float4 , Metadata_EmissionColor)</span><br><span class="line">#define _Cutoff                 UNITY_ACCESS_DOTS_INSTANCED_PROP_FROM_MACRO(float  , Metadata_Cutoff)</span><br><span class="line">#define _Smoothness             UNITY_ACCESS_DOTS_INSTANCED_PROP_FROM_MACRO(float  , Metadata_Smoothness)</span><br><span class="line">#define _Metallic               UNITY_ACCESS_DOTS_INSTANCED_PROP_FROM_MACRO(float  , Metadata_Metallic)</span><br><span class="line">#define _BumpScale              UNITY_ACCESS_DOTS_INSTANCED_PROP_FROM_MACRO(float  , Metadata_BumpScale)</span><br><span class="line">#define _Parallax               UNITY_ACCESS_DOTS_INSTANCED_PROP_FROM_MACRO(float  , Metadata_Parallax)</span><br><span class="line">#define _OcclusionStrength      UNITY_ACCESS_DOTS_INSTANCED_PROP_FROM_MACRO(float  , Metadata_OcclusionStrength)</span><br><span class="line">#define _ClearCoatMask          UNITY_ACCESS_DOTS_INSTANCED_PROP_FROM_MACRO(float  , Metadata_ClearCoatMask)</span><br><span class="line">#define _ClearCoatSmoothness    UNITY_ACCESS_DOTS_INSTANCED_PROP_FROM_MACRO(float  , Metadata_ClearCoatSmoothness)</span><br><span class="line">#define _DetailAlbedoMapScale   UNITY_ACCESS_DOTS_INSTANCED_PROP_FROM_MACRO(float  , Metadata_DetailAlbedoMapScale)</span><br><span class="line">#define _DetailNormalMapScale   UNITY_ACCESS_DOTS_INSTANCED_PROP_FROM_MACRO(float  , Metadata_DetailNormalMapScale)</span><br><span class="line">#define _Surface                UNITY_ACCESS_DOTS_INSTANCED_PROP_FROM_MACRO(float  , Metadata_Surface)</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">TEXTURE2D(_ParallaxMap);        SAMPLER(sampler_ParallaxMap);</span><br><span class="line">TEXTURE2D(_OcclusionMap);       SAMPLER(sampler_OcclusionMap);</span><br><span class="line">TEXTURE2D(_DetailMask);         SAMPLER(sampler_DetailMask);</span><br><span class="line">TEXTURE2D(_DetailAlbedoMap);    SAMPLER(sampler_DetailAlbedoMap);</span><br><span class="line">TEXTURE2D(_DetailNormalMap);    SAMPLER(sampler_DetailNormalMap);</span><br><span class="line">TEXTURE2D(_MetallicGlossMap);   SAMPLER(sampler_MetallicGlossMap);</span><br><span class="line">TEXTURE2D(_SpecGlossMap);       SAMPLER(sampler_SpecGlossMap);</span><br><span class="line">TEXTURE2D(_ClearCoatMap);       SAMPLER(sampler_ClearCoatMap);</span><br><span class="line"></span><br><span class="line">half4 SampleMetallicSpecGloss(float2 uv, half albedoAlpha)</span><br><span class="line">...</span><br><span class="line">half SampleOcclusion(float2 uv)</span><br><span class="line">...</span><br><span class="line">half2 SampleClearCoat(float2 uv)</span><br><span class="line">...</span><br><span class="line">void ApplyPerPixelDisplacement(half3 viewDirTS, inout float2 uv)</span><br><span class="line">...</span><br><span class="line">half3 ScaleDetailAlbedo(half3 detailAlbedo, half scale)</span><br><span class="line">...</span><br><span class="line">half3 ApplyDetailAlbedo(float2 detailUv, half3 albedo, half detailMask)</span><br><span class="line">...</span><br><span class="line">half3 ApplyDetailNormal(float2 detailUv, half3 normalTS, half detailMask)</span><br><span class="line">...</span><br><span class="line">inline void InitializeStandardLitSurfaceData(float2 uv, out SurfaceData outSurfaceData)</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>而LitPassForward里声明了shader里用到的Attributes和Varyings结构体，用来读入模型的顶点信息、处理几何阶段问题。</p>
<figure class="highlight plaintext"><figcaption><span>代码</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">struct Attributes</span><br><span class="line">&#123;</span><br><span class="line">    float4 positionOS   : POSITION;</span><br><span class="line">    float3 normalOS     : NORMAL;</span><br><span class="line">    float4 tangentOS    : TANGENT;</span><br><span class="line">    float2 texcoord     : TEXCOORD0;</span><br><span class="line">    float2 staticLightmapUV   : TEXCOORD1;</span><br><span class="line">    float2 dynamicLightmapUV  : TEXCOORD2;</span><br><span class="line">    UNITY_VERTEX_INPUT_INSTANCE_ID</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct Varyings</span><br><span class="line">&#123;</span><br><span class="line">    float2 uv                       : TEXCOORD0;</span><br><span class="line"></span><br><span class="line">#if defined(REQUIRES_WORLD_SPACE_POS_INTERPOLATOR)</span><br><span class="line">    float3 positionWS               : TEXCOORD1;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    float3 normalWS                 : TEXCOORD2;</span><br><span class="line">#if defined(REQUIRES_WORLD_SPACE_TANGENT_INTERPOLATOR)</span><br><span class="line">    half4 tangentWS                : TEXCOORD3;    // xyz: tangent, w: sign</span><br><span class="line">#endif</span><br><span class="line">    float3 viewDirWS                : TEXCOORD4;</span><br><span class="line"></span><br><span class="line">#ifdef _ADDITIONAL_LIGHTS_VERTEX</span><br><span class="line">    half4 fogFactorAndVertexLight   : TEXCOORD5; // x: fogFactor, yzw: vertex light</span><br><span class="line">#else</span><br><span class="line">    half  fogFactor                 : TEXCOORD5;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if defined(REQUIRES_VERTEX_SHADOW_COORD_INTERPOLATOR)</span><br><span class="line">    float4 shadowCoord              : TEXCOORD6;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if defined(REQUIRES_TANGENT_SPACE_VIEW_DIR_INTERPOLATOR)</span><br><span class="line">    half3 viewDirTS                : TEXCOORD7;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    DECLARE_LIGHTMAP_OR_SH(staticLightmapUV, vertexSH, 8);</span><br><span class="line">#ifdef DYNAMICLIGHTMAP_ON</span><br><span class="line">    float2  dynamicLightmapUV : TEXCOORD9; // Dynamic lightmap UVs</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    float4 positionCS               : SV_POSITION;</span><br><span class="line">    UNITY_VERTEX_INPUT_INSTANCE_ID</span><br><span class="line">    UNITY_VERTEX_OUTPUT_STEREO</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在Varings里，代码中不断用define来判定是否需要声明变量来使得性能达到最优。</p>
<p>后面的InitializeInputData()函数通过Varings、法线贴图的采样值和一些全局变量直接输出了InputData。这个InputData在之前已经有介绍，有了InputData几乎就可以直接在Lighting.hlsl函数里计算光照结果了。</p>
<p>顶点着色器的函数使用了Unity的GetVertexXXXInputs()函数，可以方便地输出一个属性在各个空间的值而不需要多行的矩阵乘法，是一个节省代码量的写法，不过我个人还是不太喜欢用。顶点着色器里还有一些其他的变量处理，在全局光照的时候再分析吧。</p>
<figure class="highlight plaintext"><figcaption><span>代码</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// Used in Standard (Physically Based) shader</span><br><span class="line">Varyings LitPassVertex(Attributes input)</span><br><span class="line">&#123;</span><br><span class="line">    Varyings output = (Varyings)0;</span><br><span class="line"></span><br><span class="line">    UNITY_SETUP_INSTANCE_ID(input);</span><br><span class="line">    UNITY_TRANSFER_INSTANCE_ID(input, output);</span><br><span class="line">    UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);</span><br><span class="line">    </span><br><span class="line">    VertexPositionInputs vertexInput = GetVertexPositionInputs(input.positionOS.xyz);</span><br><span class="line">    </span><br><span class="line">    // normalWS and tangentWS already normalize.</span><br><span class="line">    // this is required to avoid skewing the direction during interpolation</span><br><span class="line">    // also required for per-vertex lighting and SH evaluation</span><br><span class="line">    VertexNormalInputs normalInput = GetVertexNormalInputs(input.normalOS, input.tangentOS);</span><br><span class="line">    </span><br><span class="line">    half3 vertexLight = VertexLighting(vertexInput.positionWS, normalInput.normalWS);</span><br><span class="line">    </span><br><span class="line">    half fogFactor = 0;</span><br><span class="line">    #if !defined(_FOG_FRAGMENT)</span><br><span class="line">        fogFactor = ComputeFogFactor(vertexInput.positionCS.z);</span><br><span class="line">    #endif</span><br><span class="line">    </span><br><span class="line">    output.uv = TRANSFORM_TEX(input.texcoord, _BaseMap);</span><br><span class="line">    </span><br><span class="line">    // already normalized from normal transform to WS.</span><br><span class="line">    output.normalWS = normalInput.normalWS;</span><br><span class="line">#if defined(REQUIRES_WORLD_SPACE_TANGENT_INTERPOLATOR) || defined(REQUIRES_TANGENT_SPACE_VIEW_DIR_INTERPOLATOR)</span><br><span class="line">    real sign = input.tangentOS.w * GetOddNegativeScale();</span><br><span class="line">    half4 tangentWS = half4(normalInput.tangentWS.xyz, sign);</span><br><span class="line">#endif</span><br><span class="line">#if defined(REQUIRES_WORLD_SPACE_TANGENT_INTERPOLATOR)</span><br><span class="line">    output.tangentWS = tangentWS;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if defined(REQUIRES_TANGENT_SPACE_VIEW_DIR_INTERPOLATOR)</span><br><span class="line">    half3 viewDirWS = GetWorldSpaceNormalizeViewDir(vertexInput.positionWS);</span><br><span class="line">    half3 viewDirTS = GetViewDirectionTangentSpace(tangentWS, output.normalWS, viewDirWS);</span><br><span class="line">    output.viewDirTS = viewDirTS;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    OUTPUT_LIGHTMAP_UV(input.staticLightmapUV, unity_LightmapST, output.staticLightmapUV);</span><br><span class="line">#ifdef DYNAMICLIGHTMAP_ON</span><br><span class="line">    output.dynamicLightmapUV = input.dynamicLightmapUV.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;</span><br><span class="line">#endif</span><br><span class="line">    OUTPUT_SH(output.normalWS.xyz, output.vertexSH);</span><br><span class="line">#ifdef _ADDITIONAL_LIGHTS_VERTEX</span><br><span class="line">    output.fogFactorAndVertexLight = half4(fogFactor, vertexLight);</span><br><span class="line">#else</span><br><span class="line">    output.fogFactor = fogFactor;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if defined(REQUIRES_WORLD_SPACE_POS_INTERPOLATOR)</span><br><span class="line">    output.positionWS = vertexInput.positionWS;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if defined(REQUIRES_VERTEX_SHADOW_COORD_INTERPOLATOR)</span><br><span class="line">    output.shadowCoord = GetShadowCoord(vertexInput);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    output.positionCS = vertexInput.positionCS;</span><br><span class="line">    </span><br><span class="line">    return output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>片元着色器就显得简单一点，首先提前跑一下位移贴图的变换，然后直接初始化InputData，接下来就用Lighting.hlsl中的UniversalFragmentPBR()函数输出颜色。</p>
<figure class="highlight plaintext"><figcaption><span>代码</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// Used in Standard (Physically Based) shader</span><br><span class="line">half4 LitPassFragment(Varyings input) : SV_Target</span><br><span class="line">&#123;</span><br><span class="line">    UNITY_SETUP_INSTANCE_ID(input);</span><br><span class="line">    UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(input);</span><br><span class="line"></span><br><span class="line">#if defined(_PARALLAXMAP)</span><br><span class="line">#if defined(REQUIRES_TANGENT_SPACE_VIEW_DIR_INTERPOLATOR)</span><br><span class="line">    half3 viewDirTS = input.viewDirTS;</span><br><span class="line">#else</span><br><span class="line">    half3 viewDirWS = GetWorldSpaceNormalizeViewDir(input.positionWS);</span><br><span class="line">    half3 viewDirTS = GetViewDirectionTangentSpace(input.tangentWS, input.normalWS, viewDirWS);</span><br><span class="line">#endif</span><br><span class="line">    ApplyPerPixelDisplacement(viewDirTS, input.uv);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    SurfaceData surfaceData;</span><br><span class="line">    InitializeStandardLitSurfaceData(input.uv, surfaceData);</span><br><span class="line">    </span><br><span class="line">    InputData inputData;</span><br><span class="line">    InitializeInputData(input, surfaceData.normalTS, inputData);</span><br><span class="line">    SETUP_DEBUG_TEXTURE_DATA(inputData, input.uv, _BaseMap);</span><br><span class="line"></span><br><span class="line">#ifdef _DBUFFER</span><br><span class="line">    ApplyDecalToSurfaceData(input.positionCS, surfaceData, inputData);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    half4 color = UniversalFragmentPBR(inputData, surfaceData);</span><br><span class="line">    </span><br><span class="line">    color.rgb = MixFog(color.rgb, inputData.fogCoord);</span><br><span class="line">    color.a = OutputAlpha(color.a, _Surface);</span><br><span class="line">    </span><br><span class="line">    return color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>明明全局光照、阴影mask以及分开的clearCoat还没有分析，怎么就总结了。</p>
<p>因为今天已经结束了，该下班了，明天继续。</p>
<p>前半部分其实已经对Unity默认shader光照结构有一定的认识了。总结一下就是urp采用了现在很多人都喜欢使用的一种方式（确实是很容易管理的一种方式）——将.shader和其使用的着色器函数分开在不同的文件里，前者只进行properties的声明以及pass的声明和调用，而后者在urp中又分为两块——properties中input变量的处理一块，attributes、varings以及顶点着色器和片元着色器函数一块，这样的方式并没有看见很多人在使用，但个人觉得非常不错，因为在不同的shader间迭代的时候我们往往会碰见这样的情况：因为shader需要实现的功能需求不同导致它需要不同的变量参数，但是着色器的算法却大同小异，将两者分离开来不仅有助于提高效率，也能减少写代码中犯错的概率。</p>
<p>这是urp中shader的结构，再整理一下它的文件结构：Lighting.hlsl作为一个光照计算的总入口，它的底层指向了BRDF.hlsl等库，而BRDF.hlsl作为实现PBR光照方程的库，本身包含了DirectBRDFSpecular()和EnvironmentBRDF()两个重要函数，它的底层是BSDF.hlsl、CommonMaterial.hlsl等库，前者包含了很多光照的方程，而后者包含了一些常用的PBR材质的属性的变换函数。Input.hlsl用于传递片元的各种各样的参数，而光源的参数则在Lighting.hlsl中的UniversalFragmentPBR()中遍历直接光、采样间接光获取，并放入同文件的LightingPhysicallyBased()中运算，这个函数又调用了BRDF.hlsl中的的DirectBRDFSpecular()和EnvironmentBRDF()中进行运算。</p>
<p>unity他把这个方程拆成了多个部分，我们可以看出D项和Vis项是在BRDF.hlsl中计算的，而L*NoL和F项的部分又是在Lighting.hlsl中计算的。</p>
<p>按照CatlikeCoding的说法，urp中使用的BRDF方程是一个修改过的轻量级的方程，如果自己写过BRDF方程代码的朋友们也会发现urp中的默认材质和按照常见的BRDF方程写出来的直接光照部分并没有太大的区别，但是间接光照部分会有不小的区别（毕竟Lighting.hlsl中考虑到的东西比较全面）</p>
<p>那么次回再探讨全局光照、阴影、雾效部分。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="https://emiteinna.github.io">EmiteInna</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://emiteinna.github.io">https://emiteinna.github.io</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">此文章版权归EmiteInna所有，多看看吧。</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://emiteinnakuru.oss-cn-shanghai.aliyuncs.com/image/images/qt03.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/game/demo7/" title="UnityURPshader光照部分学习分析（中）-全局光照和阴影雾效"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://emiteinnakuru.oss-cn-shanghai.aliyuncs.com/image/images/qt03.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">UnityURPshader光照部分学习分析（中）-全局光照和阴影雾效</div></div></a></div><div class="next-post pull-right"><a href="/game/demo5/" title="游戏向参考链接目录"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://emiteinnakuru.oss-cn-shanghai.aliyuncs.com/image/images/qt03.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">游戏向参考链接目录</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://emiteinnakuru.oss-cn-shanghai.aliyuncs.com/image/images/knifesmall.png" onerror="this.onerror=null;this.src='https://emiteinnakuru.oss-cn-shanghai.aliyuncs.com/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">EmiteInna</div><div class="author-info__description">和风帆大人一起建立的个人主页，和技术无关的东西估计会放b站上。主要方向是游戏程序、游戏美术和一些渲染部分，什么都做一点，但都不太会。</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">89</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/emiteinna"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#UnityURPshader%E5%85%89%E7%85%A7%E9%83%A8%E5%88%86%E5%AD%A6%E4%B9%A0%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%8A%EF%BC%89-%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">UnityURPshader光照部分学习分析（上）-基本结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#BRDF%E6%96%B9%E7%A8%8B"><span class="toc-number">1.1.</span> <span class="toc-text">BRDF方程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lighting-hlsl"><span class="toc-number">1.2.</span> <span class="toc-text">Lighting.hlsl</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#BRDF-hlsl"><span class="toc-number">1.2.1.</span> <span class="toc-text">BRDF.hlsl</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SurfaceData-hlsl"><span class="toc-number">1.2.2.</span> <span class="toc-text">SurfaceData.hlsl</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E5%88%B0BRDF-hlsl-%E4%B8%8D%E9%82%A3%E4%B9%88%E7%86%9F%E6%82%89%E7%9A%84BRDF%E6%96%B9%E7%A8%8B"><span class="toc-number">1.2.3.</span> <span class="toc-text">回到BRDF.hlsl-不那么熟悉的BRDF方程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BSDF-hlsl"><span class="toc-number">1.2.4.</span> <span class="toc-text">BSDF.hlsl</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CommonMaterial-hlsl"><span class="toc-number">1.2.5.</span> <span class="toc-text">CommonMaterial.hlsl</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E5%88%B0Lighting-hlsl"><span class="toc-number">1.2.6.</span> <span class="toc-text">回到Lighting.hlsl</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E4%BD%93-UniversalFragmentPBR"><span class="toc-number">1.2.7.</span> <span class="toc-text">正体-UniversalFragmentPBR</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Input-hlsl"><span class="toc-number">1.2.8.</span> <span class="toc-text">Input.hlsl</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%8A%E4%B8%80%E6%AE%B5%E8%90%BD"><span class="toc-number">1.2.9.</span> <span class="toc-text">告一段落</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lit-shader"><span class="toc-number">1.3.</span> <span class="toc-text">Lit.shader</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#LitInput-hlsl%E5%92%8CLitForwardPass-hlsl"><span class="toc-number">1.3.1.</span> <span class="toc-text">LitInput.hlsl和LitForwardPass.hlsl</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.4.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/game/demo7/" title="UnityURPshader光照部分学习分析（中）-全局光照和阴影雾效"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://emiteinnakuru.oss-cn-shanghai.aliyuncs.com/image/images/qt03.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="UnityURPshader光照部分学习分析（中）-全局光照和阴影雾效"/></a><div class="content"><a class="title" href="/game/demo7/" title="UnityURPshader光照部分学习分析（中）-全局光照和阴影雾效">UnityURPshader光照部分学习分析（中）-全局光照和阴影雾效</a><time datetime="2023-04-09T06:09:09.000Z" title="Created 2023-04-09 14:09:09">2023-04-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/game/demo6/" title="UnityURPshader光照部分学习分析（上）-基本结构"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://emiteinnakuru.oss-cn-shanghai.aliyuncs.com/image/images/qt03.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="UnityURPshader光照部分学习分析（上）-基本结构"/></a><div class="content"><a class="title" href="/game/demo6/" title="UnityURPshader光照部分学习分析（上）-基本结构">UnityURPshader光照部分学习分析（上）-基本结构</a><time datetime="2023-04-08T04:58:59.000Z" title="Created 2023-04-08 12:58:59">2023-04-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/game/demo5/" title="游戏向参考链接目录"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://emiteinnakuru.oss-cn-shanghai.aliyuncs.com/image/images/qt03.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="游戏向参考链接目录"/></a><div class="content"><a class="title" href="/game/demo5/" title="游戏向参考链接目录">游戏向参考链接目录</a><time datetime="2023-03-22T04:58:59.000Z" title="Created 2023-03-22 12:58:59">2023-03-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/game/demo4/" title="URP轮子合集"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://emiteinnakuru.oss-cn-shanghai.aliyuncs.com/image/images/qt03.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="URP轮子合集"/></a><div class="content"><a class="title" href="/game/demo4/" title="URP轮子合集">URP轮子合集</a><time datetime="2023-03-15T04:34:32.000Z" title="Created 2023-03-15 12:34:32">2023-03-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/game/demo2/" title="ComputeShader整活-屏幕碎裂剥落效果"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://emiteinnakuru.oss-cn-shanghai.aliyuncs.com/image/images/qt03.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ComputeShader整活-屏幕碎裂剥落效果"/></a><div class="content"><a class="title" href="/game/demo2/" title="ComputeShader整活-屏幕碎裂剥落效果">ComputeShader整活-屏幕碎裂剥落效果</a><time datetime="2023-03-04T04:34:32.000Z" title="Created 2023-03-04 12:34:32">2023-03-04</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By EmiteInna</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">不必理解，只需感受；不必惊慌，因我在此。</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script id="canvas_nest" defer="defer" color="127,127,127" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>